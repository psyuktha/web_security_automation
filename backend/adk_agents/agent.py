import dotenv
from google.adk.agents import Agent, SequentialAgent
from google.adk.runners import Runner
from google.adk.sessions import InMemorySessionService
import asyncio
import os
from google.genai import types
from dotenv import load_dotenv
load_dotenv()
import json
# from backend.services import execute

payload_agent = Agent(
    name="payload_agent",
    model="gemini-1.5-flash",
    description='''You are the Payload Agent. Your task is to generate potential penetration testing payloads 
    for given web application endpoints. These endpoints include path, methods (GET, POST), and form fields.

    For each unique path, you will return a dictionary with:
    - The endpoint path as a key
    - A nested dictionary as value containing:
      - Each form field name as key
      - A relevant attack payload as values
    
    For example:    
    ```
    {
      "/login": {
        "email": ["test@example.com", "' OR 1=1--", "<script>alert(1)</script>"],
        "password": ["password123", "' OR '1'='1", "admin' --"]
      },
      "/register": {
        "name": ["test", "<script>alert(1)</script>", "'; DROP TABLE users;--"],
        "email": ["test@example.com", "admin@' OR 1=1--"]
        // other fields...
      }
    }
    ```

    For each field, generate 1 payload that are relevant based on the form field types:
    - For `email` fields: email format attacks and email-based injections
    - For `password` fields: SQLi or encoding-based attacks
    - For `text` fields: XSS, LFI, command injections, etc.
    - For `hidden` fields (like _token): CSRF attacks

    Include common attack types:
    - SQL Injection (`' OR 1=1--`, `admin' --`)
    - Cross-site Scripting (XSS) (`<script>alert(1)</script>`)
    - Server-Side Request Forgery (SSRF) (`http://127.0.0.1`, `file:///etc/passwd`)
    - Local File Inclusion (LFI) (`../../../../etc/passwd`)
    - Command Injection (`; ls -la`, `&& whoami`)
    '''
)

attack_agent = Agent(
    name="attack_agent",
    model="gemini-1.5-flash",
    description='''You are the Attack Agent. Your ONLY task is to perform penetration testing attacks on web application endpoints.
    You will receive a list of endpoints with their respective methods and form fields. 
    For each endpoint, you will generate a list of curl commands using the payloads generated by the Payload Agent.''',
    # tools=[execute],
    instruction="generate a list of curl commands for each endpoint using the payloads provided by the Payload Agent")

root_agent = SequentialAgent(
    name="sequential_agent",
    description="You are the Sequential Agent. Your task is to manage and coordinate the execution of other agents in a sequential manner. "
                "If the user provides a list of endpoints, you will use the Payload Agent to generate potential payloads for each endpoint."
                "If the user provides a list of payloads, you will use the Attack Agent to perform penetration testing attacks on the endpoints using the payloads.",
    sub_agents=[payload_agent, attack_agent]
)


# Runtime configuration (lazy-initialized to avoid side-effects on import)
APP_NAME = "redteam"
USER_ID = "user_123"
SESSION_ID = "session_456"

# Internal runtime holders
_session_service = None
_runner = None
_session = None

def _has_genai_credentials():
    """Check for genai credentials preferring GOOGLE_API_KEY in env.

    Returns True if we can construct a Client with provided inputs, False otherwise.
    """
    api_key = os.environ.get("GOOGLE_API_KEY")
    try:
        from google.genai import client as genai_client
        if api_key:
            # Try constructing the client with api_key â€” this will raise if invalid/missing
            genai_client.Client(api_key=api_key)
            return True
        # Fall back to default constructor (may raise if no other config present)
        genai_client.Client()
        return True
    except Exception:
        return False


async def init_runtime_async(app_name: str = APP_NAME, user_id: str = USER_ID, session_id: str = SESSION_ID):
    """Async initializer: create session and runner. Safe to call multiple times.

    Returns the Runner instance.
    """
    global _session_service, _runner
    if _runner is not None:
        return _runner

    _session_service = InMemorySessionService()
    session = await _session_service.create_session(
        app_name=app_name,
        user_id=user_id,
        session_id=session_id
    )
    # persist the created session object in module state for later access
    global _session
    _session = session
    print(f"Created session: {session}")

    _runner = Runner(
        agent=root_agent,
        app_name=app_name,
        session_service=_session_service
    )
    return _runner


def init_runtime_sync(app_name: str = APP_NAME, user_id: str = USER_ID, session_id: str = SESSION_ID):
    """Synchronous initializer that runs the async initializer when called from sync code."""
    return asyncio.run(init_runtime_async(app_name=app_name, user_id=user_id, session_id=session_id))


def run_query(query: str):
    """Synchronous wrapper around `run_query_async`.

    Use `run_query_async` if you are already inside an asyncio event loop.
    """
    return asyncio.run(run_query_async(query))


def save_session_to_file(path: str) -> dict:
    """Save the currently-initialized session to a JSON file.

    Returns a dict with keys: success (bool), path (str) and message or error.
    """
    if _session is None:
        return {"success": False, "error": "No session initialized yet. Call run_query or init_runtime first."}

    # Build a serializable representation using common attributes.
    session_data = {}
    for attr in ("id", "session_id", "app_name", "user_id", "state", "events", "last_update_time"):
        # Some session implementations may use different attribute names
        val = getattr(_session, attr, None)
        # also try without trailing underscore for id/session_id mismatch
        if val is None and attr == "session_id":
            val = getattr(_session, "id", None)
        session_data[attr] = val

    try:
        with open(path, "w") as f:
            json.dump(session_data, f, default=str, indent=2)
        return {"success": True, "path": path, "message": "Session saved."}
    except Exception as e:
        return {"success": False, "error": str(e)}

async def run_query_async(query: str):
    """Async entrypoint that awaits the runner's async API.

    Returns the final response text or an error message when credentials are missing.
    """
    if not _has_genai_credentials():
        return (
            "LLM client not configured.\n"
            "Set the Google AI API key or Google Cloud (vertexai, project & location) "
            "configuration before calling the agent. For example:\n"
            "export GOOGLE_API_KEY=your_api_key_here\n"
        )

    runner = await init_runtime_async()

    content = types.Content(role="user", parts=[types.Part(text=query)])
    async for event in runner.run_async(user_id=USER_ID, session_id=SESSION_ID, new_message=content):
        if event.is_final_response():
            print(_session)
            return event.content.parts[0].text
    return "No response received."

if __name__ == "__main__":
    # Example of usage when executed as a script (sync wrapper)
    resp = run_query('''{
    "forms": [
        {
            "action": "search.php?test=query",
            "method": "post",
            "id": "",
            "class": [],
            "inputs": [
                {
                    "type": "text",
                    "name": "searchFor",
                    "id": "",
                    "required": false,
                    "placeholder": "",
                    "value": "",
                    "tag": "input"
                },
                {
                    "type": "submit",
                    "name": "goButton",
                    "id": "",
                    "required": false,
                    "placeholder": "",
                    "value": "go",
                    "tag": "input"
                }
            ]
        }]''')
    print(resp)
    save_session_to_file("session_456.json")