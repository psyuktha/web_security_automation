import dotenv
from google.adk.agents import Agent, SequentialAgent
from google.adk.runners import Runner
from google.adk.sessions import InMemorySessionService
import asyncio
import os
from google.genai import types
from dotenv import load_dotenv
load_dotenv()
import json


def execute(curl: List[str]) -> List[Dict]:
    """
    Execute a list of curl commands and return the results.

    Args:
        curl (List[str]): List of curl commands to execute.

    Returns:
        List[Dict]: List of results per curl command. Each result contains:
            - success (bool)
            - output (str, if success)
            - error (str, if failed)
            - status_code (int)
    """
    results = []

    for curl_command in curl:
        print(f"Executing command: {curl_command}")

        if not curl_command or not curl_command.strip().startswith("curl"):
            results.append({
                "success": False,
                "error": "Invalid curl command. Command must start with 'curl'.",
                "status_code": -1
            })
            continue

        try:
            args = shlex.split(curl_command)
            result = subprocess.run(
                args,
                capture_output=True,
                text=True,
                timeout=30
            )

            if result.returncode == 0:
                results.append({
                    "success": True,
                    "output": result.stdout.strip(),
                    "status_code": 0
                })
            else:
                results.append({
                    "success": False,
                    "error": result.stderr.strip(),
                    "status_code": result.returncode
                })
        except subprocess.TimeoutExpired:
            results.append({
                "success": False,
                "error": "Command execution timed out after 30 seconds",
                "status_code": -1
            })

        except Exception as e:
            results.append({
                "success": False,
                "error": f"Error executing curl command: {str(e)}",
                "status_code": -1
            })

    return results
# AI Payload Generator Agent
payload_generator_agent = Agent(
    name="payload_generator_agent",
    model="gemini-2.5-flash",
    description='''You are the AI Payload Generator Agent. Your task is to generate diverse and effective 
    penetration testing payloads for web application endpoints. 

    You will receive:
    - Endpoint information (URL, HTTP method, parameters, form fields)
    - Context about the target application (if available)
    - Previous attack results (if available) for feedback-based improvement

    For each endpoint, generate a comprehensive set of payloads covering:
    - SQL Injection: ' OR 1=1--, admin' --, UNION SELECT, etc.
    - Cross-site Scripting (XSS): <script>alert(1)</script>, <img src=x onerror=alert(1)>, etc.
    - Command Injection: ; ls -la, && whoami, | cat /etc/passwd, etc.
   
    Consider the field type and context:
    - Email fields: email format attacks and email-based injections
    - Password fields: SQLi, encoding-based attacks, authentication bypass
    - Text fields: XSS, LFI, command injections, template injection
    - Hidden fields: CSRF token manipulation, parameter pollution
    - Numeric fields: SQLi, NoSQL injection, integer overflow

    Return payloads in a structured format that can be easily consumed by the Select Payload agent.
    Use feedback from previous attack results to improve payload generation (e.g., if XSS was blocked, 
    try encoding or obfuscation techniques).
    '''
)

# Select Payload Agent
select_payload_agent = Agent(
    name="select_payload_agent",
    model="gemini-2.5-flash",
    description='''You are the Select Payload Agent. Your task is to intelligently select the most 
    appropriate payloads from those generated by the Payload Generator Agent.

    You will receive:
    - A list of generated payloads for each endpoint/field
    - Endpoint context (method, parameters, field types)
    - Previous attack results (if available)
    - Target application characteristics (if available)

    Your selection criteria should consider:
    1. **Relevance**: Match payload type to field type and endpoint context
    2. **Effectiveness**: Prioritize payloads with higher success rates for similar contexts
    3. **Diversity**: Ensure coverage across different attack vectors
    4. **Efficiency**: Select payloads that are likely to reveal vulnerabilities quickly
    5. **Feedback Learning**: If previous attacks failed, select alternative approaches

    Return a filtered and prioritized list of payloads, with reasoning for each selection.
    Format the output to be easily consumed by the Attack agent.
    '''
)

# Attack Agent
attack_agent = Agent(
    name="attack_agent",
    model="gemini-2.5-flash",
    description='''You are the Attack Agent. Your ONLY task is to execute penetration testing attacks 
    on web application endpoints using the selected payloads.

    You will receive:
    - Selected payloads from the Select Payload Agent
    - Endpoint information (URL, method, parameters)
    - Attack configuration (if any)

    For each selected payload, generate a properly formatted HTTP request (curl command or equivalent):
    - For GET requests: Include payload in URL parameters
    - For POST requests: Include payload in request body (form-data, JSON, etc.)
    - For other methods: Format appropriately (PUT, PATCH, DELETE, etc.)
    - Include necessary headers (Content-Type, User-Agent, etc.)
    - Handle authentication if required

    Generate executable curl commands that can be used to test the endpoints.
    Ensure proper encoding and formatting for each payload type.
    '''
)

# Result Agent
result_agent = Agent(
    name="result_agent",
    model="gemini-2.5-flash",
    description='''You are the Result Agent. Your task is to analyze attack results and provide 
    feedback for the fuzzing engine.

    You will receive:
    - HTTP response data (status codes, headers, body)
    - Attack payloads that were used
    - Endpoint information

    Analyze the results to:
    1. **Identify Vulnerabilities**: Detect signs of successful exploitation:
       - SQL errors indicating SQL injection
       - XSS execution indicators
       - File inclusion evidence
       - Command execution output
       - Authentication bypass
       - Information disclosure

    2. **Categorize Results**:
       - Successful exploitation (vulnerability found)
       - Potential vulnerability (needs further investigation)
       - Blocked/Filtered (WAF or security controls detected)
       - No vulnerability (clean response)

    3. **Generate Feedback**:
       - What worked and why
       - What didn't work and why
       - Recommendations for next iteration
       - Suggested payload modifications

    Return structured results with vulnerability assessments and feedback for the Payload Generator 
    to improve future payload generation.
    '''
)

# Root Sequential Agent with Feedback Loop
root_agent = SequentialAgent(
    name="fuzzing_engine_agent",
    description='''You are the Fuzzing Engine Agent. Your task is to coordinate a comprehensive 
    fuzzing workflow for web application security testing.

    The workflow consists of:
    1. **AI Payload Generator**: Generate diverse attack payloads for given endpoints
    2. **Select Payload**: Intelligently select the most appropriate payloads
    3. **Attack**: Execute attacks using the selected payloads

    When a user provides:
    - Endpoint information: Start the full cycle (Generate → Select → Attack )

    Always maintain context across iterations to improve effectiveness through the feedback loop.
    ''',
    sub_agents=[payload_generator_agent, select_payload_agent, attack_agent]
)


# Runtime configuration (lazy-initialized to avoid side-effects on import)
APP_NAME = "fuzzing_engine"
USER_ID = "user_123"
SESSION_ID = "session_456"

# Internal runtime holders
_session_service = None
_runner = None
_session = None

def _has_genai_credentials():
    """Check for genai credentials preferring GOOGLE_API_KEY in env.

    Returns True if we can construct a Client with provided inputs, False otherwise.
    """
    api_key = os.environ.get("GOOGLE_API_KEY")
    try:
        from google.genai import client as genai_client
        if api_key:
            # Try constructing the client with api_key — this will raise if invalid/missing
            genai_client.Client(api_key=api_key)
            return True
        # Fall back to default constructor (may raise if no other config present)
        genai_client.Client()
        return True
    except Exception:
        return False


async def init_runtime_async(app_name: str = APP_NAME, user_id: str = USER_ID, session_id: str = SESSION_ID):
    """Async initializer: create session and runner. Safe to call multiple times.

    Returns the Runner instance.
    """
    global _session_service, _runner
    if _runner is not None:
        return _runner

    _session_service = InMemorySessionService()
    session = await _session_service.create_session(
        app_name=app_name,
        user_id=user_id,
        session_id=session_id
    )
    # persist the created session object in module state for later access
    global _session
    _session = session
    print(f"Created session: {session}")

    _runner = Runner(
        agent=root_agent,
        app_name=app_name,
        session_service=_session_service
    )
    return _runner


def init_runtime_sync(app_name: str = APP_NAME, user_id: str = USER_ID, session_id: str = SESSION_ID):
    """Synchronous initializer that runs the async initializer when called from sync code."""
    return asyncio.run(init_runtime_async(app_name=app_name, user_id=user_id, session_id=session_id))


def run_query(query: str):
    """Synchronous wrapper around `run_query_async`.

    Use `run_query_async` if you are already inside an asyncio event loop.
    """
    return asyncio.run(run_query_async(query))


def save_session_to_file(path: str) -> dict:
    """Save the currently-initialized session to a JSON file.

    Returns a dict with keys: success (bool), path (str) and message or error.
    """
    if _session is None:
        return {"success": False, "error": "No session initialized yet. Call run_query or init_runtime first."}

    # Build a serializable representation using common attributes.
    session_data = {}
    for attr in ("id", "session_id", "app_name", "user_id", "state", "events", "last_update_time"):
        # Some session implementations may use different attribute names
        val = getattr(_session, attr, None)
        # also try without trailing underscore for id/session_id mismatch
        if val is None and attr == "session_id":
            val = getattr(_session, "id", None)
        session_data[attr] = val

    try:
        with open(path, "w") as f:
            json.dump(session_data, f, default=str, indent=2)
        return {"success": True, "path": path, "message": "Session saved."}
    except Exception as e:
        return {"success": False, "error": str(e)}

async def run_query_async(query: str):
    """Async entrypoint that awaits the runner's async API.

    Returns the final response text or an error message when credentials are missing.
    """
    if not _has_genai_credentials():
        return (
            "LLM client not configured.\n"
            "Set the Google AI API key or Google Cloud (vertexai, project & location) "
            "configuration before calling the agent. For example:\n"
            "export GOOGLE_API_KEY=your_api_key_here\n"
        )

    runner = await init_runtime_async()

    content = types.Content(role="user", parts=[types.Part(text=query)])
    async for event in runner.run_async(user_id=USER_ID, session_id=SESSION_ID, new_message=content):
        if event.is_final_response():
            print(_session)
            return event.content.parts[0].text
    return "No response received."

if __name__ == "__main__":
    # Example of usage when executed as a script
    resp = run_query('''{
    "endpoints": [
        {
            "url": "https://example.com/login",
            "method": "POST",
            "parameters": {
                "email": "user@example.com",
                "password": "password123"
            }
        }
    ]}''')
    print(resp)
    save_session_to_file("fuzzing_session.json")

