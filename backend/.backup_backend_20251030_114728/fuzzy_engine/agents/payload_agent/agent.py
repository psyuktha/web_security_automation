from google.adk.agents import Agent, SequentialAgent
from google.adk.runners import Runner
from google.adk.sessions import InMemorySessionService
from google.genai import types
import json
from dotenv import load_dotenv
load_dotenv()

payload_agent = Agent(
    name="payload_agent",
    model="gemini-2.0-flash-exp",
    description='''You are the Payload Agent. Your task is to generate potential penetration testing payloads 
    for given web application endpoints. These endpoints include path, methods (GET, POST), and form fields.

    For each unique path, you will return a dictionary with:
    - The endpoint path as a key
    - A nested dictionary as value containing:
      - Each form field name as key
      - A relevant attack payload as values
    
    For example:    
    ```
    {
      "/login": {
        "email": ["test@example.com", "' OR 1=1--", "<script>alert(1)</script>"],
        "password": ["password123", "' OR '1'='1", "admin' --"]
      },
      "/register": {
        "name": ["test", "<script>alert(1)</script>", "'; DROP TABLE users;--"],
        "email": ["test@example.com", "admin@' OR 1=1--"]
        // other fields...
      }
    }
    ```

    For each field, generate 1 payload that are relevant based on the form field types:
    - For `email` fields: email format attacks and email-based injections
    - For `password` fields: SQLi or encoding-based attacks
    - For `text` fields: XSS, LFI, command injections, etc.
    - For `hidden` fields (like _token): CSRF attacks

    Include common attack types:
    - SQL Injection (`' OR 1=1--`, `admin' --`)
    - Cross-site Scripting (XSS) (`<script>alert(1)</script>`)
    - Server-Side Request Forgery (SSRF) (`http://127.0.0.1`, `file:///etc/passwd`)
    - Local File Inclusion (LFI) (`../../../../etc/passwd`)
    - Command Injection (`; ls -la`, `&& whoami`)
    '''
)


attack_agent = Agent(
    name="attack_agent",
    model="gemini-2.0-flash-exp",
    description='''You are the Attack Agent.
    You will receive a list of endpoints with their respective methods and form fields. 
    For each endpoint, you will generate a list of curl commands using the payloads generated by the Payload Agent.''',
    # tools=[execute],
    instruction="generate a list of curl commands for each endpoint using the payloads provided by the Payload Agent")

root_agent = SequentialAgent(
    name="sequential_agent",
    description="You are the Sequential Agent. Your task is to manage and coordinate the execution of other agents in a sequential manner. "
                "If the user provides a list of endpoints, you will use the Payload Agent to generate potential payloads for each endpoint."
                "If the user provides a list of payloads, you will use the Attack Agent to perform penetration testing attacks on the endpoints using the payloads.",
    sub_agents=[payload_agent, attack_agent]
)

session_service = InMemorySessionService()
runner = Runner(
    agent=root_agent,
    app_name="payload_app",
    session_service=session_service
)
USER_ID = "user_payload"
SESSION_ID = "session_payload"

async def execute(request):
    # create_session is async â€” await so the session is actually created before running
    await session_service.create_session(
        app_name="payload_app",
        user_id=USER_ID,
        session_id=SESSION_ID
    )
    prompt = request["prompt"]
    message = types.Content(role="user", parts=[types.Part(text=prompt)])
    async for event in runner.run_async(user_id=USER_ID, session_id=SESSION_ID, new_message=message):
        if event.is_final_response():
            response_text = event.content.parts[0].text
            try:
                parsed = json.loads(response_text)
                print(runner.agent.name, "execution completed.")
                return {"activities": parsed}

            except json.JSONDecodeError as e:
                print("JSON parsing failed:", e)
                print("Response content:", response_text)
                print(runner.agent.name, "execution completed.")
                return {"activities": response_text}  # fallback to raw text
    